#!/usr/bin/env python
# Copyright 2019 The Johns Hopkins University Applied Physics Laboratory
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import argparse
import shutil
import os
import subprocess
import parse
import resource 
# Inputs will be of the form
# TO -> --bucket test_bucket
#       --directory 12f2/stepname
#       f1 f2 f3 f4
# Should upload f1..4 to S3://test_bucket/12f2/stepname
# FROM -> --bucket test_bucket
#         --directory 12f2/stepname
#         f1 f2 f3 f4
# Should download S3://test_bucket/12f2/stepname/f1..4 to current dir


parser = argparse.ArgumentParser(
)
# TODO fix dependence on last file being in the same bucket
# As an implementation note, this will fail if the last download file is from another bucket

parser.add_argument('--input', help='Comma delimited list of files to download in the form /directory/file')
parser.add_argument('--output', help='Comma delimited list of files to upload in the form /directory/file')
parser.add_argument('--wf', help = 'Workflow name in the form of saber_bucket/wf_hash')
parser.add_argument('command', nargs=argparse.REMAINDER, help='The actual command being run form of command args ...')

args = parser.parse_args()
if args.wf:
    volume_path = '../volumes/data/local/{}/'.format(args.wf)
else:
    volume_path = '../volumes/data/local/' 
if not os.path.exists(volume_path):
        os.makedirs(volume_path) # creates the volume path if it doesn't exist already

if args.input:
    infiles = args.input.split(',') #list of input files with parent directorys e.g. ['boss_pull_raw.0/pull_output.npy']
    for f in infiles:
        fs = f.split('/') #splits directory from file name e.g. ['boss_pull_raw.0', 'pull_output.npy']
        fn = fs[len(fs)-1] #gets the file name e.g. 'pull_output.npy'
        source = volume_path + fn
        if len(fs) > 1: 
            target = '/'.join(fs[:-1]) # gets the parent directories e.g. 'boss_pull_raw.0'
            target = target[:-2] #gets rid of the '.0' 
            
            if not os.path.exists(target):
                os.makedirs(target) # creates the parent directories in the CWD if it doesn't exist already
        else:
            #fs is just the filename
            target = fs[0]
        
        try:
            shutil.copy(source, target)
        except OSError as e:
            print('Got error {} while input copying file {}'.format(e, fn))
            raise e

proc = subprocess.call(args.command, shell=False)
if proc != 0:
    raise SystemError('Child process failed with exit code {}... exiting...'.format(proc)) 

if args.output:
    outfiles = args.output.split(',') #list of output files with parent directorys e.g. ['boss_pull_raw.0/pull_output.npy']
    for f in outfiles:
        fs = f.split('/')
        fn = fs[len(fs)-1]
        #fp = '/'.join(fs[:-1])
        #data_path = os.makedirs('../volumes/data/local/{}'.format(fp))
        try: 
            #TODO: change output file names
            shutil.copy(fn, volume_path)
        except OSError as e:
            print('Got error {} while copying file {}'.format(e, fn))
            raise e
        print('Deleting file to free space...')
        os.remove(fn)
print('TOTAL MEMORY USED: {}'.format(resource.getrusage(0).ru_maxrss))
